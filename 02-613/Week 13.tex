% document formatting
\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}
\usepackage[T1]{fontenc}
\usepackage{xcolor}

% math symbols, etc.
\usepackage{amsmath, amsfonts, amssymb, amsthm}

% lists
\usepackage{enumerate}

% images
\usepackage{graphicx} % for images
\usepackage{tikz}
\usetikzlibrary{intersections, calc}

% code blocks
% \usepackage{minted, listings} 

% verbatim greek
\usepackage{alphabeta}

\newcommand{\opt}{\texttt{OPT}}

\graphicspath{{./assets/images/Week 13}}

\title{02-613 Week 13 \\ \large{Algorithms and Advanced Data Structures}}
 
\author{Aidan Jan}

\date{\today}

\begin{document}
\maketitle

\section*{The Simplex Method}
Suppose we have a system we want to optimize under some constraints.   Say, maximize $z = x_1 + x_2$ under the constraints
\begin{align*}
    x_1 + x_2 &\leq 3 \\
    x_1 - 3x_2 &\geq -1 \\
    x_2 &\leq 3 \\
\end{align*}
Additionally, let all $x_i \geq 0$.\\\\
To use the simplex method, we first need to get these constraints into the \textbf{standard form}, which is to maximize $\vec{c} \cdot \vec{x}$, subject to $A \vec{x} \leq \vec{b}$ and $\vec{x} \geq 0$.\\\\
In our case, we need to do some rewriting.  First, we have a greater than sign, which is not allowed.  Therefore, we can convert it to a $\leq$ by multiplying both sides of the equation by $-1$.
\begin{align*}
    x_1 + x_2 &\leq 3 \\
    - x_1 + 3x_2 &\leq 1 \\
    x_2 &\leq 3
\end{align*}
Now, we add slack variables $S1, S2, S3$.
\begin{align*}
    x_1 + x_2 + S1 &\leq 3 \\
    - x_1 + 3x_2 + S2 &\leq 1 \\
    x_2 + S3 &\leq 3
\end{align*}
and rearrange the equations to solve for them.
\begin{align*}
    S1 &\leq 3 - x_1 - x_2 \\
    S2 &\leq 1 + x_1 - 3x_2\\
    S3 &\leq 3 - x_2
\end{align*}

[FILL rest of example]

\subsection*{The Simplex Algorithm}
\begin{enumerate}
    \item Write linear program with slack variables and get an initial feasible solution
    \item Choose variable $v$ in objective with positive coefficient.
    \item Choose strictest constraint (will be one with negative coefficient on pivot)
    \item Rewrite strictest constraint with $v$ on the left hand side and subs in others
    \item If all coefficients in the objective function are negative, then we are done.  Otherwise, return to step 2.
\end{enumerate}

\subsection*{Pivot Rules}
\begin{itemize}
    \item Largest coefficient in objective
    \item Largest increase after pivot
    \item Random
    \item Steepest change
    \item Bland's Rule - choose pivot $v$ with lower index  (This prevents infinite loops by always choosing the smallest index.)
\end{itemize}

\section*{NP Completeness}
The phrase `NP-Hard' tends to be used interchangeably with `non-polynomial'.  However, they are not the same thing.

\subsection*{Decision vs. Optimization Problems}
\begin{itemize}
	\item \textbf{Decision:} A problem that asks for a True/False solution.  
	\item \textbf{Optimization:} A problem that asks for minimizing or maximizing some objective function.
\end{itemize}
Conveniently, any optimization problem can be turned into a decision problem with an extra parameter.  For example:
\begin{itemize}
	\item \textbf{Optimization:} Given graph $G = (V, E)$, and $w$ weight on all edges, find the spanning tree with minimum total weight.
	\item \textbf{Decision:} Does there exist a spanning tree with at most $\leq k$ weight?
\end{itemize}
We refer to decision questions as `problems'.  Now we can define $P$ and $NP$.

\subsection*{P vs. NP}
\textbf{Class P} is a set of problems. A problem $Q \in P$, if there exists an algorithm $A_Q$ such that, for all instances $I$ of $Q$, $A_Q(I)$ runs in polynomial($|I|$) steps and
\begin{itemize}
	\item If $I$ is a yes instance $A_Q(I)$ = yes
	\item If $I$ is a no instance $A_Q(I)$ = no
\end{itemize}
\textbf{Class NP} is a set of problems.  A problem $Q \in NP$ if a \textbf{non-deterministic} Turing machine can return YES on a YES instance in polynomial time.
A problem $Q \in NP$ if evidence of a Yes-instance can be verified in polynomial time.  More formally, NP is a set of problems, $Q$ for when there exists an algorithm $C_Q(\cdot)$ such that for all $I$ of $Q$:
\begin{itemize}
	\item If $I$ is YES, then $C_Q(I, S)$ = Yes, for some $S$
	\item If $I$ is NO, then $C_Q(I, S)$ = No, for all $S$
	\item Additionally, $C_Q(\cdot)$ runs in polynomial time.
\end{itemize}
This implies that problems can be both $P$ \textit{and} $NP$.  $P \subset NP$.

\subsection*{Example: NP-Hard}
Consider the traveling salesman decision problem.  Given distances $d_{ij}$ between $n$ cities and a number $k$, is there a way to visit all cities exactly once, with total length of less than or equal to $k$?
\begin{itemize}
	\item If given a valid certificate and a $k$-value (e.g., a YES instance), it is provable in polynomial time.
	\item Finding a valid certificate (e.g., an instance that satisfies the problem), is not possible though.  Therefore, it is an NP-hard question.
\end{itemize}

\subsection*{Theorem: $P \subseteq NP$}
Proof: Suppose $x \in P$  There exists a polynomial alorithm $A_x(\cdot)$. To show $X \in NP$, need efficient certifier $C_x(I, S) = A_x(I)$.  Therefore, $P \subseteq NP$.  Now, does $P = NP$?  It turns out this is a hard problem in itself, and no proof exists for it. 

\subsection*{Problem Reductions}
A reduction from problem $X$ to $Y$ (written as $X \leq_P Y$), it means for instance $I_X$ of $X$, create a new instance $(I_X)_Y$ in polynomial time, such that \{$(I_X)_Y$ is a yes instance $\longleftrightarrow$ $I_X$ is a YES-instance\}, and $Y$ is \textbf{at least as hard} as $X$.
\begin{itemize}
	\item This implies that if there exists no polynomial time solution for $X$, then there must also not exist a polynomial time solution for $Y$.
\end{itemize}

\subsection*{Cook-Levin Theorem (1971)}
This theorem states that every problem in NP can be reduced to SAT, or the satisfyability problem.  The boolean satisfiability problem is NP-complete. \\\\
In turn, SAT can be reduced to 3SAT, which can be reduced to Independent set, vertex cover, set cover, hamiltonian path, TSP, graph coloring, 3D matching, and more.

\subsection*{The SAT problem}
Suppose we have many boolean variables, $x_1, x_2, \dots$, and a series of terms $t_1, t_2, \dots$, where $t_i = x_i$ or $t_j = \bar{x_i}$.  To combine terms, we have the two boolean operators, AND ($\land$) and OR ($\lor$).  We write in conjunctive normal form, or CNF (AND-of-ORs, sum-of-products).\\\\
The problem is, if given an expression, e.g.
\[(x_1 \lor \bar{x_2}) \land (\bar{x_1} \lor \bar{x_3}) \land (x_2 \lor x_3)\]
does there exist a truth assignment (choice of T/F for each variable) such that the entire expression returns true?  A \textbf{satisfying assignment} is a truth assignment that makes the formula true.\\\\
This problem is NP-complete.

\subsection*{The 3SAT problem}
The 3SAT problem is a subset of SAT, where every OR clause contains exactly three terms.  We care about this specific subset because as it turns out, every SAT problem is reducable to 3SAT.  How is this possible?\\\\
There are three cases in converting a SAT problem to a 3SAT problem.  Either the clause in SAT has less than 3 terms, exactly 3 terms, or more than 3 terms.
\begin{itemize}
    \item If there are exactly three terms, then nothing changes.  This case already meets the conditions for 3SAT.
    \item If there are less than three terms, then duplicate a variable.  e.g., $(t_1 \lor t_2) = (t_1 \lor t_2 \lor t_2)$.
    \item If there are more than three terms, this process is less trivial.  To do this case, we add variables in the following way:
\end{itemize}
\begin{align*}
    &\hspace{0.5cm}(t_1 \lor t_2 \lor t_3 \lor t_4 \lor \cdots \lor t_k) \\
    &= (t_1 \lor t_2 \lor \textcolor{red}{Y_1}) \land \\
    &\hspace{1.9cm} (\textcolor{red}{\bar{Y_1}} \lor t_3 \lor \textcolor{red}{Y_2}) \land\\
    &\hspace{3.4cm} (\textcolor{red}{\bar{Y_2}} \lor t_4 \lor \textcolor{red}{Y_3}) \land\\
    &\hspace{4.2cm} \cdots \land\\
    &\hspace{5.7cm} (\textcolor{red}{\bar{Y}_{k - 1}} \lor t_{k - 1} \lor t_k)
\end{align*}
Doing this reduction does not keep the same statement as the original, but it has the property that it is satisfiable if and only if the original is satisfiable.  Additionally, every clause only contains three terms.
\begin{itemize}
    \item If there is a way to satisfy the original, it means that at least one term from the original OR statement must be true.  
    \item In 3-SAT, if we broke that OR clause into $k$ separate clauses, then we have $k - 1$ $Y$-variables.  Since at least one clause is true, then there is a way to pick the $k - 1$ $Y$-variables to satisfy the rest, making the statement true.
    \item If the original cannot be satisfied, then we have $k - 1$ variables, but $k$ clauses, and therefore we cannot satisfy all of the clauses.
\end{itemize}

\end{document}