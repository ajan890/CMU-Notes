% document formatting
\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}
\usepackage[T1]{fontenc}
\usepackage{xcolor}

% math symbols, etc.
\usepackage{amsmath, amsfonts, amssymb, amsthm}

% lists
\usepackage{enumerate}

% images
\usepackage{graphicx} % for images
\usepackage{tikz}

% code blocks
% \usepackage{minted, listings} 

% verbatim greek
\usepackage{alphabeta}

\graphicspath{{./assets/images/Week 9}}

\title{02-613 Week 9 \\ \large{Algorithms and Advanced Data Structures}}
 
\author{Aidan Jan}

\date{\today}

\begin{document}
\maketitle

\section*{Suffix Tries}
Problem: Given a large known, fixed \textbf{text}, e.g. a dictionary, and many unknowns of changing search queries, how do we design a data structure that can quickly search up terms in the structure, but also substrings?
\begin{itemize}
	\item For example, if ``uninterested'' was in the dictionary, and we wanted to search for ``interested'' or ``interest'', they should both show up.
	\item Using any of our structures so far, there is not an efficient way to do this.
	\item What we \textit{can} do is make a tree, where each node represents a letter, where every suffix is a path from the root to some leaf node.
\end{itemize}
[insert image here]

This structure allows for searching for any word in our dictionary, but also any suffix.
\begin{itemize}
	\item This is known as a \textbf{trie}.  (Not a tree, since trees don't allow internal nodes with only one child.)
\end{itemize}

\subsection*{Runtime of Tries}
The runtime of a trie is $\Theta(\Sigma)$, where $\Sigma$ is the size of our alphabet.  For the English alphabet, $\Sigma = 27$  (26 letters, plus an end-of-word marker, $\mathdollar$.)
\begin{itemize}
	\item Similarly, a DNA sequence would have $\Sigma = 5$ since it includes $A, C, T, G, \mathdollar$.
	\item We add a $\mathdollar$ to be able to distinguish when a valid string ends.  If we want to find if a query is a suffix of our text, then the terminators become very important.
\end{itemize}

\subsection*{Searching in Tries}
To search for a term $q$ in our text $T$, we simply follow the path down from the root, since every substring would have a unique path from the root.
\begin{itemize}
	\item If we want to know if $q$ is a suffix of $T$, we can do that too since $q$ would be a substring of $T$.
	\item If we want to know the number of times $q$ is in $T$, then we follow the path down for $q$, and at the last character, count the number of leaf nodes in the subtree.
	\item To find the longest repeated substring, we return the deepest branching node.
	\item To find the lexicographically smallest suffix, from the root we follow the tree down always following the branch with the smallest character, assuming $\mathdollar$ is less than any other character in our alphabet.
\end{itemize}

\section*{Suffix Trees}
To be continued...

\end{document}